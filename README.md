# Конструювання класів з перезавантаженням операторів
**Мета**: створити, відлагодити та протестувати програму, у якій створити класи та реалізувати перевантаження операторів, які підтримують роботу та взаємодію об'єктів класу для обробки даних.

## Вказівки до роботи
Відповідно до цієї інструкції вам потрібно у середовищі Visual Studio Code з використанням набору компіляторів GCC створити програму  мовою C++ класи та реалізувати перевантаження операторів, які підтримують роботу та взаємодію об'єктів класу для обробки даних, також реалізувати відповідні конструктори, деструктори, методи. Потрібно реалізувати багатофайловий проєкт у середовищі Visual Studio Code описом кожного класу у відповідних парах заголовного та виконуваного файлів.
1. Ознайомитися із можливостями мови С++ для перевантаження операторів, навчитись  використовувати їх при роботі з класами та об'єктами. Обдумати способи їх використання для створення програм.
2. Вибрати завдання згідно свого варіанту у ДОДАТКУ.
3. Розробити блок-схему алгоритму програми.
4. Реалізувати програму для вводу і виводу даних полів (членів) структур вкладених у клас.

## Короткі відомості
Перевантаження функцій забезпечує механізм створення і виконання викликів функцій з одним і тим же ім’ям, але з різними параметрами. Це дозволяє одній функції працювати з декількома різними типами даних (без необхідності придумувати унікальні імена для кожної з функцій).

У мові C++ оператори реалізовані у вигляді функцій. Використовуючи перевантаження функції оператора, ви можете визначити свої власні версії операторів, які працюватимуть з різними типами даних (включаючи класи). Використання перевантаження функції для перевантаження оператора називається перевантаженням оператора. Ви можете перевантажити оператор + для з’єднання об’єктів вашого класу `String` або для виконання операції додавання двох об’єктів вашого класу `Fraction`. Ви можете перевантажити оператор `<<` для виводу вашого класу на екран (або запису в файл). Ви можете перевантажити оператор рівності `(==)` для порівняння двох об’єктів класу і т.д. Подібні застосування роблять перевантаження операторів однією з найкорисніших особливостей мови C++, так як це спрощує процес роботи з класами і відкриває нові можливості.

По-перше, майже будь-який існуючий оператор в мові C++ можна перевантажити. Винятками є:
- тернарний оператор (`? :`);
- оператор `sizeof`;
- оператор дозволу області видимості (`::`);
- оператор вибору члена (`.`);
- вказівник, як оператор вибору члена (`.*`).

По-друге, ви можете перевантажити тільки існуючі оператори. Ви не можете створювати нові або перейменовувати існуючі. Наприклад, ви не можете створити оператор `**` для виконання операції піднесення до степеня.

По-третє, принаймні один з операндів перевантаженого оператора повинен бути користувацького типу даних. Це означає, що ви не можете перевантажити `operator+()` для виконання операції додавання значення типу `int` до значення типу `double`. Однак ви можете перевантажити `operator+()` для виконання операції додавання значення типу `int` до об’єкта класу `Mystring`.

По-четверте, початкову кількість операндів, підтримуваних оператором, змінити неможливо. Тобто з бінарним оператором використовуються тільки два операнди, з унарним — тільки один, з тернарним — тільки три.

Нарешті, всі оператори зберігають свої пріоритети і асоціативність за замовчуванням (незалежно від того, для чого вони використовуються), і це не може бути змінено. При перевантаженні операторів намагайтеся максимально наближено зберігати функціонал операторів з їх початковими призначеннями.

Арифметичні оператори плюс (`+`), мінус (`-`), множення (`*`) і ділення (`/`) є одними з найбільш використовуваних операторів у мові C++. Всі вони є бінарними, тобто працюють тільки з двома операндами.

Є три різних способи перевантаження операторів:
- через дружні функції;
- через звичайні функції;
- через методи класу.

Використання дружньої функції для перевантаження оператора зручно тим, що ми маємо прямий доступ до всіх членів класу, з яким працюємо. Дружня функція перевантаження оператора має прямий доступ до закритого члену класу.

Однак, якщо нам не потрібен доступ до членів певного класу, ми можемо перевантажити оператор і через звичайну функцію. Якщо в класі є геттер, то за його допомогою ми можемо отримати доступ до члена класу ззовні класу. Оскільки принцип перевантаження операторів через звичайні і дружні функції майже ідентичний (вони просто мають різні рівні/умови доступу до закритих членів класу), то єдина відмінність полягає в тому, що у випадку з дружньою функцією, її потрібно обов’язково оголосити в класі, але визначити поза тілом класу (або в класі), в той час як звичайну функцію досить просто визначити поза тілом класу, без вказівки додаткового прототипу функції.

Для перевантаження операторів рекомендується використовувати звичайні функції, а не дружні, якщо в класі, звичайно, присутні геттери (чим менше функцій стосується внутрішніх елементів вашого класу, тим краще). Однак не додавайте додатковий геттер тільки для того, щоб перевантажити оператор через звичайну функцію замість дружньої! Використовуйте перевантаження операторів через звичайні функції, замість дружніх, якщо для цього не потрібне додавання додаткових функцій в клас. Якщо геттера немає за замовчуванням або він не використовується взагалі (в ньому немає необхідності), то тоді використовуйте перевантаження через дружні функції. 

Перевантаження операторів через методи класу дуже схоже на перевантаження операторів через дружні функції. Але при перевантаженні оператора через метод класу лівим операндом стає неявний об’єкт, на який вказує прихований вказівник `*this`.

Не все можна перевантажити через дружні функції — оператори присвоювання (`=`), індексу (`[]`), виклику функції (`()`) і вибору члену (`->`) перевантажуються через методи класу — це вимога мови C++.

Не все можна перевантажити через методи класу — перевантаження операторів через методи класу не використовується, якщо лівий операнд не є класом (наприклад, `int`), або це клас, який ми не можемо змінити (наприклад, `std::ostream`).

У більшості випадків мова C++ дозволяє вибирати самостійно спосіб перевантаження операторів. Але при роботі з бінарними операторами, які не змінюють лівий операнд (наприклад, `operator+()`), зазвичай використовується перевантаження через звичайну або дружню функцію, оскільки таке перевантаження працює для всіх типів даних параметрів (навіть якщо лівий операнд не є об’єктом класу або є об’єктом класу, який змінити не можна). Перевантаження через звичайну/дружню функцію має додаткову перевагу «симетрії», так як всі операнди стають явними параметрами (а не як у перевантаженні через метод класу, коли лівий операнд стає неявним об’єктом, на який вказує вказівник `*this`).

При роботі з бінарними операторами, які змінюють лівий операнд (наприклад, `operator+=()`), зазвичай використовується перевантаження через методи класу. У цих випадках лівим операндом завжди є об’єкт класу, на який вказує прихований вказівник `*this`.

Унарні оператори зазвичай теж перевантажуються через методи класу, так як в такому випадку параметри не використовуються взагалі. Зверніть увагу, плутанини між від’ємними унарними операторами плюс (`+`) та мінус (`-`) і бінарними операторами плюс (`+`) та мінус (`-`) немає, так як вони мають різну кількість параметрів. Оскільки оператори інкременту (`++`) та декременту (`−−`) є унарними і змінюють свої операнди, то перевантаження слід виконувати через методи класу. 

Тому користуйтеся такими правилами:
- Для операторів присвоювання (`=`), індексу (`[]`), виклику функції (`()`) або вибору члена (`->`) використовуйте перевантаження через методи класу.
- Для унарних операторів використовуйте перевантаження через методи класу.
- Для перевантаження бінарних операторів, які змінюють лівий операнд (наприклад, `operator+=()`) використовуйте перевантаження через методи класу, якщо це можливо.
- Для перевантаження бінарних операторів, які не змінюють лівий операнд (наприклад, `operator+()`) використовуйте перевантаження через звичайні/дружні функції. 
- Не перевантажуйте оператори, які є зайвими для вашого класу.

Принципи перевантаження операторів порівняння ті ж самі, що і в перевантаженні інших операторів, які ми розглядали на попередніх уроках. Оскільки всі оператори порівняння є бінарними і не змінюють свої ліві операнди, то виконувати перевантаження потрібно через дружні функції.
```c++
#include <iostream>
class Complex {
private:
    double real;
    double imag;
public:
    Complex(double r, double i) : real(r), imag(i) {}
    // Перевантаження оператора додавання
    /*
    Complex operator+(const Complex& other) const
    -   Complex: Це тип, який повертає оператор. У даному випадку, це об'єкт класу Complex.
    -   operator+: Це оголошення перевантаженого оператора додавання.
    -   const Complex& other: Це параметр, який передається оператору. Він є константним посиланням на інший об'єкт класу Complex.
    -   const: Цей оператор не змінює стан об'єкта, для якого він викликається.
    */
    Complex operator+(const Complex& other) const {
        return Complex(real + other.real, imag + other.imag);
    }
    Complex operator-(const Complex& other) const {
        return Complex(real - other.real, imag - other.imag);
    }
    // Метод для виведення комплексного числа
    void display() const {
        std::cout << real << " + " << imag << "i" << std::endl;
    }
};
int main() {
    // Використання перевантаженого оператора додавання
    Complex c1(2.0, 3.5);
    Complex c2(1.5, -2.0);
    Complex c3(-1.5, -1.0);
    Complex result_sum = c1 + c2;
    Complex result_sub = c2 - c3;
    result_sum.display(); // Результат: 3.5 + 1.5i
    result_sub.display(); // Результат: 3 + -1i
    return 0;
}
```

Але, як ви знаєте, оператори `>` і `<=` є логічними протилежностями, тому один з них можна було б визначити через інший, так само як і `<` і `>=`. 

Зазвичай перевантаження функцій здійснюється, якщо вони мають одне і те ж ім’я, але різну кількість і типи параметрів. Розглянемо випадок з операторами інкременту/декременту версій префікс/постфікс. Обидва мають одне і те ж ім’я (наприклад, `operator++`), унарні і приймають один параметр одного і того ж типу даних. Як же тоді їх розрізнити при перевантаженні? 

Справа в тому, що мова C++ використовує фіктивну змінну (або «фіктивний параметр») для операторів версії постфікс. Цей фіктивний цілочисельний параметр використовується тільки з однією метою: відрізнити версію постфікс операторів інкременту/декременту від версії префікс.

Оператори версії префікс повертають об’єкт після того, як він був збільшений або зменшений. У версії постфікс нам потрібно повернути об’єкт до того, як він буде збільшений або зменшений. Якщо ми збільшуємо або зменшуємо об’єкт, то ми не можемо повернути його до виконання інкременту/декременту, так як операція збільшення/зменшення вже відбулася. З іншого боку, якщо ми повертаємо об’єкт до виконання інкременту/декременту, то сама операція збільшення/зменшення об’єкта не виконається.

Рішенням є використання тимчасового об’єкта з поточним значенням змінної-члена. Тоді можна буде збільшити/зменшити вихідний об’єкт, а тимчасовий об’єкт повернути назад в caller. Таким чином, caller отримає копію об’єкта до того, як фактичний об’єкт буде збільшений або зменшений, і сама операція інкременту/декременту виконається успішно.

Зверніть увагу, це означає, що повернення значення по посиланню неможливе, так як ми не можемо повернути посилання на локальну змінну (об’єкт), яка буде знищена після завершення виконання тіла функції. Також це означає, що оператори версії постфікс зазвичай менш ефективні, ніж оператори версії префікс, через додаткові витрати ресурсів на створення тимчасового об’єкта і виконання повернення по значенню замість повернення по посиланню.

Виконаємо перевантаження операторів інкременту/декременту версії префікс і постфікс в одному класі:
```c++
#include <iostream>
 
class Number
{
private:
    int m_number;
public:
    Number(int number=0)
        : m_number(number)
    {
    }
 
    Number& operator++(); // версія префікс
    Number& operator--(); // версія префікс
 
    Number operator++(int); // версія постфікс
    Number operator--(int); // версія постфікс
 
    friend std::ostream& operator<< (std::ostream &out, const Number &n);
};
 
Number& Number::operator++()
{
    /* Якщо значенням змінної m_number є 8, то скидаємо значення 
    m_number в 0
    */
    if (m_number == 8)
        m_number = 0;
 
    /* В протилежному випадку, просто збільшуємо m_number на одиницю
    */
    else
        ++m_number;
 
    return *this;
}
 
Number& Number::operator--()
{
    /* Якщо значенням змінної m_number є 0, то присвоюємо m_number
    значення 8
    */
    if (m_number == 0)
    m_number = 8;
 
    /* В протилежному випадку, просто зменшуємо m_number на одиницю
    */
    else
        --m_number;
 
    return *this;
}
 
Number Number::operator++(int)
{
    /* Створюємо тимчасовий об'єкт класу Number з поточним значенням
    змінної m_number
    */
    Number temp(m_number);
 
    /* Використовуємо оператор інкременту версії префікс для
    реалізації перевантаження оператора інкременту версії постфікс
    */
    ++(*this); // реалізація перевантаження
 
    // Повертаємо тимчасовий об'єкт
    return temp;
}
 
Number Number::operator--(int)
{
    /* Створюємо тимчасовий об'єкт класу Number з поточним значенням
    змінної m_number
    */
    Number temp(m_number);
 
    /* Використовуємо оператор декременту версії префікс для
    реалізації перевантаження оператора декременту версії постфікс
    */
    --(*this); // реалізація перевантаження
 
    // Повертаємо тимчасовий об'єкт
    return temp; 
}
 
std::ostream& operator<< (std::ostream &out, const Number &n)
{
    out << n.m_number;
    return out;
}
 
int main()
{
    Number number(6);
 
    std::cout << number;
    std::cout << ++number; // викликається Number::operator++();
    std::cout << number++; // викликається Number::operator++(int);
    std::cout << number;
    std::cout << --number; // викликається Number::operator--();
    std::cout << number--; // викликається Number::operator--(int);
    std::cout << number;
 
    return 0;
}
```

Таким чином, ми реалізували перевантаження операторів версії постфікс через вже перевантажені оператори версії префікс. Таким чином, ми зменшили дублювання коду і спростили внесення змін до нашого класу в майбутньому, тобто спростили підтримку коду.

Оператор індексації `[]` є одним з операторів, перевантаження якого повинне виконуватися через метод класу. Функція перевантаження оператора `[]` завжди прийматиме один параметр: значення індексу (елемент масиву, до якого потрібен доступ). У нашому випадку з `IntArray` нам потрібно, щоб користувач просто вказав в квадратних дужках індекс для повернення значення елементу за цим індексом:
```c++
#include <iostream>
 
class IntArray
{
private:
    int m_array[10];
 
public:
    int& operator[] (const int index);
};

int& IntArray::operator[] (const int index)
{
    return m_array[index];
}

int main()
{
    IntArray array;
    array[4] = 5; // присвоюємо значення
    std::cout << array[4]; // виводимо значення
    return 0;
}
```

Тепер щоразу, коли ми будемо використовувати оператор індексації (`[]`) з об’єктом класу `IntArray`, компілятор повертатиме відповідний елемент масиву `m_array`! Це дозволить нам безпосередньо як отримувати, так і присвоювати значення елементам `m_array`:

Все просто. При обробці `array[4]` компілятор спочатку перевіряє, чи є функція перевантаження оператора `[]`. Якщо є, то він передає в функцію перевантаження значення всередині квадратних дужок (в даному випадку 4) в якості аргументу. Зверніть увагу, хоча ми можемо вказати параметр за замовчуванням для функції перевантаження оператора `[]`, але в даному випадку, якщо ми, використовуючи `[]`, не вкажемо всередині дужок значення індексу, то отримаємо помилку. 

Розглянемо детально, як обробляється стейтмент `array[4] = 5`. Оскільки пріоритет оператора індексації вище пріоритету оператора присвоювання, то спочатку виконується частина `array[4] — array[4]` призводить до виклику функції перевантаження оператора `[]`, яка поверне `array.m_array[4]`. Оскільки оператор `[]` використовує повернення по посиланню, то він повертає фактичний елемент `array.m_array[4]`. Наш частково оброблений вираз стає `array.m_array[4] = 5`, що є прямою операцією присвоювання значення елементу масиву. 

Ми вже знаємо, що будь-яке значення, яке знаходиться зліва від оператора присвоювання, має бути l-value (змінною з адресою в пам’яті). Оскільки результат виконання оператора `[]` може використовуватися в лівій частині операції присвоювання (наприклад, `array[4] = 5`), то значення, що повертається, оператора `[]` має бути l-value. Посилання ж завжди є l-values, тому що їх можна використовувати тільки зі змінними, які мають адреси в пам’яті. Тому, використовуючи повернення по посиланню, компілятор залишиться задоволений, що повертається l-value, і ніяких проблем не буде.

Розглянемо, що станеться, якщо оператор `[]` використовуватиме повернення по значенню замість повернення по посиланню — `array[4]` призведе до виклику функції перевантаження оператора `[]`, який повертатиме значення елементу `array.m_array[4]` (не індекс, а значення за вказаним індексом). Наприклад, якщо значенням `m_array[4]` є 7, то виконання оператора `[]` призведе до повернення значення 7. `array[4] = 5` оброблятиметься як `7 = 5`, що є безглуздим! Якщо ви спробуєте це зробити, то компілятор видасть наступну помилку:
```
error C2106: '=' : left operand must be l-value 
```
У вищенаведеному прикладі метод `operator[]()` не є константним, і ми можемо використовувати цей метод для зміни даних неконстантних об’єктів. Однак, що станеться, якщо наш об’єкт класу `IntArray` буде `const`? В цьому випадку ми не зможемо викликати неконстантний `operator[]()`, так як він змінює значення об’єкту. Доброю новиною є те, що ми можемо визначити окремо неконстантну і константну версії `operator[]()`. Неконстантна версія буде використовуватися з неконстантними об’єктами, а версія `const` — з об’єктами `const`:
```c++
#include <iostream>
class IntArray
{
private:
    // вказуємо початкові значення
    int m_array[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; 
public:
    int& operator[] (const int index);
    const int& operator[] (const int index) const;
};
/* для неконстантних об'єктів: може використовуватися як для 
присвоювання значень елементам, так і для їх перегляду
*/
int& IntArray::operator[] (const int index) 
{
    return m_array[index];
}
/* для константних об'єктів: використовується тільки для перегляду 
(виводу) елементів масиву
*/
const int& IntArray::operator[] (const int index) const 
{
    return m_array[index];
}
int main()
{
    IntArray array;
    array[4] = 5; // викликається неконстантна версія operator[]()
    std::cout << array[4];
    const IntArray carray;
    std::cout << carray[4];
    return 0;
}
```
Ще однією перевагою перевантаження оператора індексації є те, що ми можемо виконати перевірку переданих значень індексу. При прямому доступі до елементів масиву (через геттери і сеттери), оператор індексу не перевіряє, чи є індекс коректним. Однак, якщо ми знаємо довжину нашого масиву, ми можемо виконати перевірку переданого індексу на коректність у функції перевантаження оператора `[]`:
```c++
#include <cassert> // для assert()
 
class IntArray
{
private:
    int m_array[10];
 
public:
    int& operator[] (const int index);
};
 
int& IntArray::operator[] (const int index)
{
    assert(index >= 0 && index < 10);
 
    return m_array[index];
}
```
У прикладі, наведеному вище, ми використовували стейтмент `assert` (який знаходиться в заголовку `cassert`) для перевірки діапазону `index`. Якщо вираз всередині `assert` приймає значення `false` (тобто користувач ввів некоректний індекс), то програма негайно завершиться з виведенням повідомлення про помилку, що краще, ніж альтернативний варіант — пошкодження пам’яті. Це найпоширеніший спосіб перевірки помилок з використанням функцій перевантаження.

Якщо ви спробуєте викликати `operator[]()` для вказівника на об’єкт, то C++ припустить, що ви намагаєтеся індексувати масив. Справа в тому, що вказівник вказує на адресу в пам’яті, а не на значення. Тому спочатку вказівник потрібно розіменувати, а потім вже використовувати оператор `[]`. В такому випадку дуже легко наробити помилок. Тому не використовуйте вказівники на об’єкти, якщо це не є обов’язковим.

Як згадувалося вище, C++ передає в функцію перевантаження те, що користувач вказав в квадратних дужках в якості аргументу (в більшості випадків, це цілочисельне значення). Однак це не є обов’язковою вимогою і, насправді, ви можете визначити функцію перевантаження так, щоб ваш перевантажений оператор `[]` приймав значення будь-якого типу, якого ви тільки побажаєте (`double`, `string` тощо). Наприклад:
```c++
#include <iostream>
#include <string>
 
class Something
{
private:
 
public:
    void operator[] (std::string index);
};
 
/* Немає сенсу перевантажувати оператор [] тільки для виводу 
будь-чого, але це найпростіший спосіб показати, що параметр 
функції може бути не тільки цілочисельним значенням
*/
void Something::operator[] (std::string index)
{
    std::cout << index;
}
 
int main()
{
    Something something;
    something["Hello, world!"];
 
    return 0;
}
```

Перевантаження оператора індексації зазвичай використовується для забезпечення прямого доступу до елементів масиву, який знаходиться всередині класу (в якості змінної-члена). Оскільки рядки часто використовуються в реалізації масивів символів, то оператор `[]` часто перевантажують в класах з рядками, щоб мати доступ до кожного символу рядка окремо.

Всі оператори, перевантаження яких ми розглядали дотепер, дозволяли нам самостійно визначати тип параметрів в функції перевантаження оператора, але не їх кількість. Наприклад, оператор `==` завжди приймає два параметри, тоді як оператор `!` завжди приймає один параметр. Оператор `()` є особливо цікавим, оскільки дозволяє змінювати як тип параметрів, так і їх кількість. 

Але слід пам’ятати про дві речі:

По-перше, перевантаження круглих дужок повинне здійснюватися через метод класу.

По-друге, в не об’єктно-орієнтованому С++ оператор `()` є оператором виклику функції. У випадку з класами перевантаження круглих дужок виконується в методі `operator()(){}` (в оголошенні функції перевантаження знаходяться дві пари круглих дужок). 

Розглянемо наступний клас:
```c++
class Matrix
{
private:
    double data[5][5];
public:
    Matrix()
    {
        // Присвоюємо всім елементам масиву значення 0.0
        for (int row=0; row < 5; ++row)
            for (int col=0; col < 5; ++col)
                data[row][col] = 0.0;
    }
};
```

Матриці є ключовою концепцією в лінійній алгебрі та часто використовуються в геометричному моделюванні і в 3D-графіці. Все, що вам потрібно зараз знати — це те, що клас `Matrix` є двовимірним масивом (5×5 типу `double`). Раніше ми використовували оператор `[]` для прямого доступу до елементів закритого одновимірного масиву. Тут же нам потрібен доступ до елементів двовимірного масиву. Оскільки оператор `[]` обмежений лише одним параметром, то його функціональності недостатньо для доступу до двовимірного масиву.

Однак, оскільки оператор `()` може приймати різну кількість параметрів, ми можемо оголосити версію `operator()`, яка прийматиме два цілочисельних параметри (два індекси), і використовуватиме ці індекси для доступу до елементів нашого двовимірного масиву. Наприклад:
```c++
#include <iostream>
#include <cassert> // для assert()
 
class Matrix
{
private:
    double data[5][5];
public:
    Matrix()
    {
        // Присвоюємо всім елементам масиву значення 0.0
        for (int row=0; row < 5; ++row)
            for (int col=0; col < 5; ++col)
                data[row][col] = 0.0;
    }
 
    double& operator()(int row, int col);
    // для константних об'єктів
    const double& operator()(int row, int col) const; 
};
 
double& Matrix::operator()(int row, int col)
{
    assert(col >= 0 && col < 5);
    assert(row >= 0 && row < 5);
 
    return data[row][col];
}
 
const double& Matrix::operator()(int row, int col) const
{
    assert(col >= 0 && col < 5);
    assert(row >= 0 && row < 5);
 
    return data[row][col];
}
 
int main()
{
    Matrix matrix;
    matrix(2, 3) = 3.6;
    std::cout << matrix(2, 3);
 
    return 0;
}
```
Виконаємо перевантаження оператора `()` ще раз, але вже без використання будь-яких параметрів:
```c++
#include <iostream>
#include <cassert> // для assert()
 
class Matrix
{
private:
    double data[5][5];
public:
    Matrix()
    {
        // Присвоюємо всім елементам масиву значення 0.0
        for (int row=0; row < 5; ++row)
            for (int col=0; col < 5; ++col)
                data[row][col] = 0.0;
    }
 
    double& operator()(int row, int col);
    const double& operator()(int row, int col) const;
    void operator()();
};
 
double& Matrix::operator()(int row, int col)
{
    assert(col >= 0 && col < 5);
    assert(row >= 0 && row < 5);
 
    return data[row][col];
}
 
const double& Matrix::operator()(int row, int col) const
{
    assert(col >= 0 && col < 5);
    assert(row >= 0 && row < 5);
 
    return data[row][col];
}
 
void Matrix::operator()()
{
    // Скидаємо значення всіх елементів масиву на 0.0
    for (int row=0; row < 5; ++row)
        for (int col=0; col < 5; ++col)
            data[row][col] = 0.0;
}
 
int main()
{
    Matrix matrix;
    matrix(2, 3) = 3.6;
    matrix(); // виконуємо скидання
    std::cout << matrix(2, 3);
 
    return 0;
}
```

Оскільки оператор `()` є дуже гнучким, то може виникнути спокуса використати його для самих різних цілей. Однак це не рекомендується робити, оскільки оператор `()` є не дуже інформативним і часто може бути не зрозуміло, що він робить. У прикладі, наведеному вище, функцію очищення масиву краще було б записати у вигляді методу `clear()` або `erase()`, оскільки `matrix.erase()` виглядає набагато інформативніше, ніж `matrix()`.

Перевантаження оператора `()` також використовується в реалізації функторів (або “функціональних об’єктів”) — класи, які працюють як функції. Перевага функтора над звичайною функцією полягає в тому, що функтори можуть зберігати дані в змінних-членах (оскільки вони самі є класами). Ось приклад використання простого функтора:
```c++
#include <iostream>
 
class Accumulator
{
private:
    int m_counter = 0;
 
public:
    Accumulator()
    {
    }
 
    int operator() (int i) { return (m_counter += i); }
};
 
int main()
{
    Accumulator accum;
    std::cout << accum(30) << std::endl; // виведеться 30
    std::cout << accum(40) << std::endl; // виведеться 70
 
    return 0;
}
```

Зверніть увагу, використання класу `Accumulator` виглядає так само, як і виклик звичайної функції, але наш об’єкт класу `Accumulator` може зберігати значення, яке збільшується. Ви можете запитати: “Навіщо використовувати клас, якщо все можна реалізувати і через звичайну функцію зі статичною локальною змінною?”. Можна зробити і через `static`, але, оскільки функції представлені тільки одним глобальним екземпляром (тобто не можна створити кілька об’єктів функції), використовувати цю функцію ми можемо тільки для виконання чогось одного за раз. За допомогою функторів ми можемо створити будь-яку кількість окремих функціональних об’єктів, які нам потрібні, і використовувати їх одночасно.

Перевантаження оператора `()` з двома параметрами використовується для отримання доступу до двовимірних масивів або для повернення підмножин одновимірного масиву (два параметри конкретизуватимуть умови відбору елементів підмножини). Все інше краще реалізувати через окремі методи з більш інформативними назвами, ніж через перевантаження оператора `()`.

Перевантаження оператора `()` також часто використовується при створенні функторів. Хоча функтори, які ми використовували вище, є досить простими і зрозумілими, але зазвичай вони використовуються в більш просунутих/складних задачах програмування.

### Оформлення звіту
У звіті студент має вказати свій варіант індивідуального завдання та представити:
1. Блок-схему алгоритму програми.
2. Код (лістинг) програми.
3. Результати тестування для різних вхідних умов.
4. Конструктивний висновок — що ви дізналися нового, чого навчилися, якими способами та інструментами досягнули мети.

## ДОДАТОК

### Варіанти завдань

1.	Перевантажити операції `>=` (порівняння двох списків за кількістю елементів), (вилучення заданого елемента зі списку), відсортувати масив екземплярів класу списків за спаданням кількості елементів, вилучити з кожного списку елементи списку з найменшою кількістю.
2.	Перевантажити операції `>=` (порівняння матриць за кількістю елементів), `*` (множення матриць), відсортувати масив екземплярів класу матриць за спаданням кількості елементів, обчислити добуток двох заданих матриць з масиву (якщо це можливо).
3.	Перевантажити операції `>=` (порівняння множин за кількістю елементів), `-` (різниця множин), відсортувати масив екземплярів класу множин за зростанням кількості елементів, обчислити різницю множин з найбільшою і найменшою кількістю елементів.
4.	Перевантажити операції `>=` (порівняння поліномів за значеннями коефіцієнтів, починаючи від найстаршого коефіцієнта), `*=` (обчислення значення полінома для заданого аргументу), відсортувати масив екземплярів класу поліномів за спаданням значень коефіцієнтів, обчислити значення кожного з поліномів у відсортованому масиві для заданого аргументу.
5.	Перевантажити операції `>=` (порівняння рядків символів за абеткою), `-` (вилучення заданого символу з рядка), відсортувати масив екземплярів класу рядків символів за зростанням в абетковому порядку, вилучити заданий символ з кожного рядка у масиві.
6.	Перевантажити операції `>=` (порівняння часу за абсолютним значенням різниці у хвилинах від поточного часу), `+=` (збільшення на n хвилин), відсортувати масив екземплярів класу часів за спаданням абсолютного значення різниці від поточного часу з використанням сортування, збільшити кожен час в масиві на задану кількість хвилин.
7.	Перевантажити операції `>` (порівняння векторів за довжиною), `*` (скалярний добуток двох векторів), відсортувати масив екземплярів класу векторів за спаданням значення мінімального елемента, обчислити скалярний добуток векторів з найбільшим і найменшим значеннями мінімального елемента.
8.	Перевантажити операції `>` (порівняння двох квадратів за довжиною головної діагоналі), `-` (зменшення довжини сторони квадрата з обчисленням нових значень діагоналі), відсортувати масив екземплярів класу квадратів за зростанням довжини головної діагоналі, зменшити довжини сторони для кожного квадрату в масиві на задане значення.
9.	Перевантажити операції `>` (порівняння двох списків за сумою елементів), `+=` (додавання елемента в кінець списку), відсортувати масив екземплярів класу списків за зростанням сум, додати до списку з найбільшою сумою елементи списку з найменшою сумою.
10.	Перевантажити операції `>` (порівняння дійсних чисел за значенням цілої частини), `[]` (виділення дробової частини числа), відсортувати масив екземплярів класу дійсних чисел за спаданням значення цілої частини, враховувати дробові частини.
11.	Перевантажити операції `>` (порівняння значень двох раціональних дробів), `+` (додавання двох дробів), відсортувати масив екземплярів класу дробів за спаданням значень з використанням сортування, обчислити середнє значення для усіх дробів у масиві (як раціональний дріб).
12.	Перевантажити операції `>` (порівняння часу за значенням різниці у секундах від 0 годин 0 хвилин 0 секунд), `-=` (зменшення на n секунд), відсортувати масив екземплярів класу часів за спаданням значення різниці від 0:00:00, зменшити кожен час в масиві на задану кількість секунд.
13.	Перевантажити операції `<` (порівняння дат за значенням різниці у днях від поточної дати), `—` (різниця між двома датами у днях), відсортувати масив екземплярів класу дат за зростанням значення різниці від поточної дати, обчислити найменшу і найбільшу різниці між датами з масиву.
14.	Перевантажити операції `<` (порівняння двох кіл за площею), `–` (різниця двох кіл координат центру та радіусів), відсортувати масив екземплярів класу кіл за зростанням площ, обчислити різницю двох кіл з найбільшою та найменшою площею у масиві.
15.	Перевантажити операції `<` (порівняння двох стеків за кількістю елементів), `+` (додавання елемента у стек), відсортувати масив екземплярів класу стеків за спаданням кількості елементів, додати елементи усіх стеків у масиві в один стек.
16.	Перевантажити операції `<` (порівняння двох сфер за площею поверхні), `-` (додавання двох сфер координат центру та радіусів), відсортувати масив екземплярів класу сфер за зростанням площ поверхні, обчислити суму двох сфер з найбільшою та найменшою площею у масиві.
17.	Перевантажити операції `<` (порівняння матриць за слідом), `+` (додавання матриць), відсортувати масив екземплярів класу матриць за спаданням сліду, обчислити суму двох заданих матриць з масиву (якщо це можливо).
18.	Перевантажити операції `<` (порівняння матриць за сумою елементів), `-` (унарний мінус —пошук мінімального елементу матриці), відсортувати масив екземплярів класу матриць за спаданням суми елементів  
19.	Перевантажити операції `<=` (порівняння векторів за довжиною), `+` (приєднання другого вектора до першого), відсортувати масив екземплярів класу векторів за зростанням довжин , обчислити середню довжину для векторів у масиві.
20.	Перевантажити операції `<=` (порівняння дат за абсолютним значенням різниці у днях від поточної дати), `==` (зменшення на 1 день), відсортувати масив екземплярів класу дат за зростанням абсолютного значення різниці від поточної дати з використанням сортування, зменшити кожну дату в масиві на задану кількість днів.
21.	Перевантажити операції `<=` (порівняння дат у календарі за днем тижня), `+` (визначення найближчої дати від заданої, яка буде днем другим операндом), відсортувати масив екземплярів класу дат у календарі за зростанням значення дня тижня з використанням алгоритму сортування вибором, для кожної дати в масиві визначити найближчу дату, яка буде заданим днем тижня.
22.	Перевантажити операції `<=` (порівняння двох конусів за об'ємом), `+` (додавання двох конусів – радіусів основи та висот), відсортувати масив екземплярів класу конусів за спаданням об'ємів, обчислити середнє значення радіусів основи та висот для конусів у масиві.
23.	Перевантажити операції `<=` (порівняння двох черг за добутком елементів), `+=` (додавання елемента в чергу), відсортувати масив екземплярів класу черг за спаданням добутків, додати до черги з найменшим добутком елементи черги з найбільшим добутком.
24.	Перевантажити операції `<=` (порівняння прямокутників за площею), `-=` (зменшення довжин сторін на значення другого операнда), відсортувати масив екземплярів класу прямокутників за зростанням площ, зменшити довжини сторін прямокутників у масиві на задане значення.
25.	Перевантажити операції `<=` (порівняння рядків символів україномовного тексту за абеткою), `*` (перевірка входження підрядка у рядок), відсортувати масив екземплярів класу рядків символів за зростанням в абетковому порядку, перевірити входження кожного рядка символів у масиві в інші рядки у цьому ж масиві.
26.	Перевантажити операції `<=` (порівняння трикутників за площею), `+=` (збільшення довжин сторін на задане значення), відсортувати масив екземплярів класу трикутників за зростанням площ, збільшити сторони трикутника в масиві на задане значення.
